# import gradio as gr
from fastapi import FastAPI
import tensorflow as tf
import numpy as np
from PIL import Image
import json
from datetime import datetime
from pydantic import BaseModel
from typing import List
from health_logic import generate_advice
from tensorflow.keras.applications.efficientnet import preprocess_input as efficientnet_preprocess
import base64
import io

app = FastAPI()

# --- Constants ---
CONFIDENCE_THRESHOLD = 0.5

# Load model
model = tf.keras.models.load_model("food_vision_model.keras")

class_names = [
    "akara", "banga_soup", "egusi_soup", "jollof_rice", "moi_moi",
    "nkwobi", "okpa", "suya", "tuwo", "yam_porridge"
]

# Load food metadata
with open("food_info.json", "r") as f:
    food_info = json.load(f)


# Risk level helper
def get_risk_level(score):
    if score <= 30:
        return "ðŸŸ¢ Low Risk"
    elif score <= 70:
        return "ðŸŸ¡ Medium Risk"
    else:
        return "ðŸ”´ High Risk"
        

# -------------------------
# Request schema
# -------------------------
class ImagePayload(BaseModel):
    image: str  # base64 string
    conditions: List[str]


def preprocess_image(b64: str):
    image_bytes = base64.b64decode(b64)
    image = Image.open(io.BytesIO(image_bytes))

    # Preprocess image
    image = image.convert("RGB").resize((224, 224))
    img = tf.keras.preprocessing.image.img_to_array(image)
    img = efficientnet_preprocess(img)
    img = np.expand_dims(img, axis=0)
    return img

@app.post("/analyze")
def analyze_food(data: ImagePayload):
    if not data.conditions:
        return {"error": "âš ï¸ Please select at least one health condition."}

    img_array = preprocess_image(data.image)

    preds = model.predict(img_array)[0]

    confidence = float(np.max(preds))
    class_index = int(np.argmax(preds))
    predicted_class = class_names[class_index]

    predictions = [
        {"label": class_names[i], "confidence": float(preds[i])}
        for i in range(len(class_names))
    ]

    food_name_for_response = predicted_class
    if confidence < CONFIDENCE_THRESHOLD:
        food_name_for_response = "unknown_food"
        return {
            "food": food_name_for_response,
            "confidence": round(confidence, 3),
            "predictions": predictions,
            "result": "Food not recognized with high confidence. Cannot generate advice.",
            "nutrients": {
                "calories": 0,
                "carbs": 0,
                "protein": 0,
                "fat": 0,
            }
        }
    
    info = food_info.get(predicted_class)
    if not info:
        return {
            "error": f"Food '{predicted_class}' found but not in database."
        }

    display_name = info.get("display_name", predicted_class.replace("_", " ").title())
    substitute = info.get("substitute")

    advice, risk_score, flags = generate_advice(info, data.conditions)
    risk_level = get_risk_level(risk_score)
   

    result_string = (
        f"ðŸ½ï¸ Food: {display_name}\n"
        f"ðŸŒ Ethnicity: {info['ethnicity']}\n"
        f"ðŸ¥¦ Ingredients: {info['ingredients']}\n"
        f"ðŸ”¥ Calories: {info['calories']} kcal\n"
        f"ðŸž Carbs: {info['carbs']}g\n"
        f"ðŸ¥© Protein: {info['protein']}g\n"
        f"ðŸ§ˆ Fat: {info['fat']}g\n"
        f"ðŸŒ± Diet Type: {info['diet_type']}\n"
        f"ðŸ” Substitute: {substitute}\n\n"
        f"ðŸ“ˆ Confidence: {round(confidence * 100, 2)}%\n"
        f"ðŸ“Š Risk Score: {risk_score}% ({risk_level})\n"
        f"âš ï¸ Risk Factors: {', '.join(flags) if flags else 'None'}\n"
        f"âœ… Advice: {advice}\n\n"
        f"ðŸ“ *Generated by HoodHealth Pro+.*"
    )

    nutrients = {
        "calories": info['calories'],
        "carbs": info['carbs'],
        "protein": info['protein'],
        "fat": info['fat'],
    }
    

    return {
    "food": food_name_for_response,
    "confidence": round(confidence, 3),
    "predictions": predictions,
    "nutrients": nutrients,
    "advice": advice, 
    "substitute": substitute
}
